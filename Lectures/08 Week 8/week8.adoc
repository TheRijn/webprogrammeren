---
---
:author: Cheng Gong

video::5aP9Bl9hcqI[youtube,height=540,width=960,options=notitle, start=4871]

== Python Classes & Web

* Let's implement structures in Python:
+
[source, python]
----
import cs50
from student import Student

students = []
for i in range(3):

    print("name: ", end="")
    name = cs50.get_string()

    print("dorm: ", end="")
    dorm = cs50.get_string()

    students.append(Student(name, dorm))

for student in students:
    print("{} is in {}.".format(student.name, student.dorm))
----
** First, we declare a `student` file that we'll soon write, and import the `Student` class from it.
** Then we can create an empty list to store students called `students`, which we can add or remove things to.
** Then we get a `name` and `dorm`, create a `Student` objects by passing those strings in as arguments, and `append` it, or add it, to the end of our list `students`. (Lists, too, have built-in functionality, one of which is `append`.)
** Finally, for each `student`, we print the properties back with the `.` syntax.
* So to create our `student` module, we would:
+
[source, python]
----
class Student:
    def __init__(self, name, dorm):
        self.name = name
        self.dorm = dorm
----
** We declare a `class` of objects called `Student`, which will only have one method, or built-in function, `__init__`, which we won't call directly but gets called when we create a `Student`
as we did above with `Student(name, dorm)`.
** This function gets the object itself as an argument and the other arguments we want to be passed in when the object is created, in this case `name` and `dorm`. Then inside the function, we store the arguments to the object that's just been created.
* We can see another convenient feature:
+
[source, python]
----
import cs50
import csv
from student import Student

students = []
for i in range(3):

    print("name: ", end="")
    name = cs50.get_string()

    print("dorm: ", end="")
    dorm = cs50.get_string()

    students.append(Student(name, dorm))

file = open("students.csv", "w")
writer = csv.writer(file)
for student in students:
    writer.writerow((student.name, student.dorm))
file.close()
----
** Now, instead of printing the students to the screen, we can write them to a file `students.csv` by opening it and using a built-in module, `csv`, that writes comma-separated values files.
** With `csv.writer(file)`, we pass in the file we open to get back a `writer` object that will take in tuples, and write them to the file for us with just `writerow`.
* If we were to run this program without `import csv`, the interpreter would start the input, collecting input like `name` and `dorm` and creating ``students``, but only when it reaches the line that calls for `csv` will it notice that it wasn't defined, and raise an exception (stop the program because there is an error).
* We can re-implement all the examples from weeks 1 through 5 in Python, and even the entire http://cdn.cs50.net/2016/fall/lectures/8/src8/speller/[`speller`] program.
* More interestingly, we can look at just the `dictionary.py` file:
+
[source, python]
----
class Dictionary:

    def __init__(self):
        self.words = set()

    def check(self, word):
        return word.lower() in self.words

    def load(self, dictionary):
        file = open(dictionary, "r")
        for line in file:
            self.words.add(line.rstrip("\n"))
        file.close()
        return True

    def size(self):
        return len(self.words)

    def unload(self):
        return True
----
** Here, we create a `words` property when each Dictionary is initialized, and set it to an empty `set`. In Python, sets are abstracted (so we don't know anything about how it's implemented in memory anymore, or whether it's a hash table, or trie, or something else entirely) but we can easily operate with it.
** We can add items to `self.words` with `self.words.add()`, check if a word is in it with `word in self.words()`, and get the size with `len(self.words)`.
** And since Python mananges our memory for us, we don't even need to worry about unloading it or freeing it.
* As we see above, a higher-level language like Python, which has implemented many lower-level features that would take dozens of lines in C, allows us to write more and more sophisticated programs without having to worry about all of the details.

[t=1h41m0s]
== Web Servers

* In Week 6 we talked about how servers and browsers communicate, but we just opened HTML files that we wrote in our own workspaces, without talking to a server that could generate a dynamic response.
* Our goal will be to implement a web server in Python, that can take in an HTTP request, and respond with some response and some generated HTML content.
* But before we get there, we need a mental model:
+
image::mvc.png[alt="MVC", width=500]
** This popular paradigm, or design pattern, for web software is called MVC, Model-View-Controller.
** The Controller has the logic for determining what the code does in response to requests, such as checking if a user is logged in.
** The View has the look of the site, with HTML templates and CSS styles.
** The Model has the data that the controller uses to fill in Views, which will then form what the user gets back.
* Today we'll focus on the V and the C.
* Python comes with built-in web server capabilities, that starts a program on your computer that listens to requests from the internet to your computer, and responds to them. We'll create our own `HTTPServer_RequestHandler` that inherits (takes the methods of) the `BaseHTTPRequestHandler` class that comes with Python:
+
[source, python]
----
from http.server import BaseHTTPRequestHandler, HTTPServer

# HTTPRequestHandler class
class HTTPServer_RequestHandler(BaseHTTPRequestHandler):

    # GET
    def do_GET(self):
        # send response status code
        self.send_response(200)

        # send headers
        self.send_header('Content-type','text/html')
        self.end_headers()

        # determine message to send to client
        if self.path == "/":
            message = "Hello, world!"
        else:
            name = self.path[1:]
            message = "Hello, {}!".format(name)

        # write message
        self.wfile.write(bytes(message, "utf8"))
        return
...
----
** We'll write our own `do_GET` function for the server that is called when a `GET` request is received. We'll always send back the response code `200`, send a header, and write a message back.
** And all of these functions and features we'd learn about from reading Python documentation online.
* Then we need to start our server:
+
[source, python]
----
...
def run():
  print('starting server...')

  # set up server
  port = 8080
  server_address = ('127.0.0.1', port)
  httpd = HTTPServer(server_address, HTTPServer_RequestHandler)

  # run server
  print('running server on port {}...'.format(port))
  httpd.serve_forever()


run()
----
** We specify the port that we want to listen to messages from, the address of the server (`127.0.0.1` is always our own computer, create an `HTTPServer` that's built-into Python, but giving it our own `HTTPServer_RequestHandler`. And finally we run it with the `serve_forever` function.
* We start the program, and nothing seems to happen. But if we open our browser and visit `http://127.0.0.1:8080` (on the CS50 IDE, the address will be different), we'll see:
+
[source]
----
hello, world
----
* But this is just text, and to write out code that generates HTML from scratch would be a lot of work.
* We can use a framework, a collection of code that contains even more functionality that we can use to build projects on top of.
* One such framework is Flask, which has some basic functionality we can use. A basic application will look something like this:
+
[source, python]
----
from flask import Flask, redirect, render_template, request, session, url_for

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/register", methods=["POST"])
def register():
    if request.form["name"] == "" or "captain" not in request.form or "comfort" not in request.form or request.form["dorm"] == "":
        return render_template("failure.html")
    return render_template("success.html")
----
** We first `import` lots of functionality `from flask`, and create an `app`.
** Then we have a line `@app.route("/")` that says the next function should be called whenever that path on the web server is requested. In this case, the function will return `render_template("index.html")`, or whatever the file `index.html` looks like.
** Then if we see `@app.route("/register", methods=["POST"])`, someone sending a `POST` request to `/register`, we'll call the `register` function underneath. That function, if we don't have certain elements in the `form`, will return the template `failure.html`. Otherwise, it'll return `success.html`.
* So we'll run this app by going to the directory with our `application.py` file, and run `$ flask run --host=0.0.0.0 --port=8080`. With `--host=0.0.0.0`, we're specifying that it listens to requests for all addresses.
* Now if we visit `http://127.0.0.1:8080` in our browser, we get back a form we've implemented in `index.html`:
+
image::form.png[alt="form", width=200]
* And if we fill out that form, we'll see an error or success message, depending on how much we've filled in:
+
image::failure.png[alt="failure", width=200]
+
image::success.png[alt="success", width=200]
** Even if we fill in the form, we aren't really registered for anything since this application doesn't have a database, or a place to store the data that we just entered.
* But in any case, let's look at `failure.html`:
+
[source]
----
{% extends "layout.html" %}

{% block title %}
Registration Failed
{% endblock %}

{% block body %}
You must provide your name, comfort, and dorm!
{% endblock %}
----
** There's not much logic here but it looks like we're extending a file called `layout.html` that probably has a basic page structure, and then with `{% block title %}` and `{% block body %}` we're indicating what should go into the title and body.
* `success.html` has something similar:
+
[source]
----
{% extends "layout.html" %}

{% block title %}
Registration Successful
{% endblock %}

{% block body %}
You are registered!  (Well, not really.)
{% endblock %}
----
* And `layout.html` is familiar:
+
[source]
----
<!DOCTYPE html>

<html>
    <head>
        <meta content="initial-scale=1, width=device-width" name="viewport"/>
        <title>{% block title %}{% endblock %}</title>
    </head>
    <body>
        {% block body %}
        {% endblock %}
    </body>
</html>
----
** We see the same `{% block title %}` and `{% block body %}` magic words in this file, which works not because of HTML or Python but because of the Flask framework (the `render_template` function) that builds pages with these templates.
* And the form in `index.html` is even more familiar:
+
[source]
----
{% extends "layout.html" %}

{% block title %}
Frosh IMs
{% endblock %}

{% block body %}
<div style="text-align:center">
    <h1>Register for Frosh IMs</h1>
    <form action="{{ url_for('register') }}" method="post">
        Name: <input name="name" type="text"/>
        <br/>
        <input name="captain" type="checkbox"/> Captain?
        <br/>
        <input name="comfort" type="radio" value="less"/> Less Comfortable
        <input name="comfort" type="radio" value="more"/> More Comfortable
        <br/>
        Dorm:
        <select name="dorm">
            <option value=""></option>
            <option value="Apley Court">Apley Court</option>
            <option value="Canaday">Canaday</option>
            <option value="Grays">Grays</option>
            <option value="Greenough">Greenough</option>
            <option value="Hollis">Hollis</option>
            <option value="Holworthy">Holworthy</option>
            <option value="Hurlbut">Hurlbut</option>
            <option value="Lionel">Lionel</option>
            <option value="Matthews">Matthews</option>
            <option value="Mower">Mower</option>
            <option value="Pennypacker">Pennypacker</option>
            <option value="Stoughton">Stoughton</option>
            <option value="Straus">Straus</option>
            <option value="Thayer">Thayer</option>
            <option value="Weld">Weld</option>
            <option value="Wigglesworth">Wigglesworth</option>
        </select>
        <br/>
        <input type="submit" value="Register"/>
    </form>
</div>
{% endblock %}
----
** The `{% block body %}` here has more HTML, a header and a form. The form also has `{{ url_for('register') }}` for its `action`, which calls a function that gets the `register` route in our app, rather than hardcodes it.
* Going back to our app where that `register` route is,
+
[source]
----
@app.route("/register", methods=["POST"])
def register():
    if request.form["name"] == "" or "captain" not in request.form or "comfort" not in request.form or request.form["dorm"] == "":
        return render_template("failure.html")
    return render_template("success.html")
----
** we see again the controller logic that checks whether the form is complete, and returns the correct view.
* We can demonstrate another simple app that lets us select how many `foo`, `bar`, and `baz` we want:
+
image::store.png[alt="store", width=200]
* And dynamically generates a page that tells us how many we've added to our cart:
+
image::cart.png[alt="cart", width=200]
* And if we closed the window and opened it, it would remember how many of each item we've added.
* The HTML for the form is simple, as well as the template for the cart:
+
[source]
----
{% extends "layout.html" %}

{% block title %}
Cart
{% endblock %}

{% block body %}

<h1>Cart</h1>

{% for item in cart %}
    {{ item["quantity"] }} : {{ item["name"] }}
    <br/>
{% endfor %}

{% endblock %}
----
** Notice that we can list each `item` in the `cart` variable with a `for` loop, and access fields of each of the `item` object, two of which at least are `quantity` and `name`.
* And we can look in `application.py` to find out what `cart` is:
+
[source]
----
from flask import Flask, redirect, render_template, request, session, url_for

app = Flask(__name__)
app.secret_key = "shhh"

@app.route("/", methods=["GET", "POST"])
def store():
    if request.method == "POST":
        for item in ["foo", "bar", "baz"]:
            if item not in session:
                session[item] = int(request.form[item])
            else:
                session[item] += int(request.form[item])
        return redirect(url_for("cart"))
    return render_template("store.html")

@app.route("/cart")
def cart():
    cart = []
    for item in ["foo", "bar", "baz"]:
        cart.append({"name":item.capitalize(), "quantity":session[item]})
    return render_template("cart.html", cart=cart)
----
** `shhh` is just some secret value that we use to keep our session, or shopping cart, secure. (Though it should be longer, and harder for someone to guess!)
** In the `store` method, we first check if the request was a `POST`. If so, meaning a user submitted the form, then we'll add the quantity indicated in the form for each `item` into `session`, if it's not in that object already, or increment its quantity if it is. And `session` is an object we get from the framework, that acts like a shopping cart, where we can save information for each user connected to our web server.
** The `cart` method creates an empty list, and stores a dictionary for each item with its name and quantity, using the session to get that value. Then we pass that into `render_template` as an argument, so we can use it to build `cart.html`, which we saw above.
* Phew, that was a lot! Yet that was barely the surface of what we have access to with the language of Python and the many many frameworks out there.
